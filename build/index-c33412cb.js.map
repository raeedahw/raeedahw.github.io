{"version":3,"file":"index-c33412cb.js","sources":["../../node_modules/scroll-behavior-polyfill/dist/index.js"],"sourcesContent":["(function () {\n    'use strict';\n\n    var UNSUPPORTED_ENVIRONMENT = typeof window === \"undefined\";\n\n    /**\n     * Is true if the browser natively supports the 'scroll-behavior' CSS-property.\n     * @type {boolean}\n     */\n    var SUPPORTS_SCROLL_BEHAVIOR = UNSUPPORTED_ENVIRONMENT ? false : \"scrollBehavior\" in document.documentElement.style;\n\n    \n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\n\n    function getScrollingElement() {\n        if (document.scrollingElement != null) {\n            return document.scrollingElement;\n        }\n        else {\n            return document.documentElement;\n        }\n    }\n\n    var STYLE_ATTRIBUTE_PROPERTY_NAME = \"scroll-behavior\";\n    var STYLE_ATTRIBUTE_PROPERTY_REGEXP = new RegExp(STYLE_ATTRIBUTE_PROPERTY_NAME + \":\\\\s*([^;]*)\");\n    /**\n     * Given an Element, this function appends the given ScrollBehavior CSS property value to the elements' 'style' attribute.\n     * If it doesnt already have one, it will add it.\n     * @param {Element} element\n     * @param {ScrollBehavior} behavior\n     */\n    function appendScrollBehaviorToStyleAttribute(element, behavior) {\n        var addition = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + behavior;\n        var attributeValue = element.getAttribute(\"style\");\n        if (attributeValue == null || attributeValue === \"\") {\n            element.setAttribute(\"style\", addition);\n            return;\n        }\n        // The style attribute may already include a 'scroll-behavior:<something>' in which case that should be replaced\n        var existingValueForProperty = parseScrollBehaviorFromStyleAttribute(element);\n        if (existingValueForProperty != null) {\n            var replacementProperty = STYLE_ATTRIBUTE_PROPERTY_NAME + \":\" + existingValueForProperty;\n            // Replace the variant that ends with a semi-colon which it may\n            attributeValue = attributeValue.replace(replacementProperty + \";\", \"\");\n            // Replace the variant that *doesn't* end with a semi-colon\n            attributeValue = attributeValue.replace(replacementProperty, \"\");\n        }\n        // Now, append the behavior to the string.\n        element.setAttribute(\"style\", attributeValue.endsWith(\";\") ? \"\" + attributeValue + addition : \";\" + attributeValue + addition);\n    }\n    /**\n     * Given an Element, this function attempts to parse its 'style' attribute (if it has one)' to extract\n     * a value for the 'scroll-behavior' CSS property (if it is given within that style attribute)\n     * @param {Element} element\n     * @returns {ScrollBehavior?}\n     */\n    function parseScrollBehaviorFromStyleAttribute(element) {\n        var styleAttributeValue = element.getAttribute(\"style\");\n        if (styleAttributeValue != null && styleAttributeValue.includes(STYLE_ATTRIBUTE_PROPERTY_NAME)) {\n            var match = styleAttributeValue.match(STYLE_ATTRIBUTE_PROPERTY_REGEXP);\n            if (match != null) {\n                var _a = __read(match, 2), behavior = _a[1];\n                if (behavior != null && behavior !== \"\") {\n                    return behavior;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    var styleDeclarationPropertyName = \"scrollBehavior\";\n    /**\n     * Determines the scroll behavior to use, depending on the given ScrollOptions and the position of the Element\n     * within the DOM\n     * @param {Element|HTMLElement|Window} inputTarget\n     * @param {ScrollOptions} [options]\n     * @returns {ScrollBehavior}\n     */\n    function getScrollBehavior(inputTarget, options) {\n        // If the given 'behavior' is 'smooth', apply smooth scrolling no matter what\n        if (options != null && options.behavior === \"smooth\")\n            return \"smooth\";\n        var target = \"style\" in inputTarget ? inputTarget : getScrollingElement();\n        var value;\n        if (\"style\" in target) {\n            // Check if scroll-behavior is set as a property on the CSSStyleDeclaration\n            var scrollBehaviorPropertyValue = target.style[styleDeclarationPropertyName];\n            // Return it if it is given and has a proper value\n            if (scrollBehaviorPropertyValue != null && scrollBehaviorPropertyValue !== \"\") {\n                value = scrollBehaviorPropertyValue;\n            }\n        }\n        if (value == null) {\n            var attributeValue = target.getAttribute(\"scroll-behavior\");\n            if (attributeValue != null && attributeValue !== \"\") {\n                value = attributeValue;\n            }\n        }\n        if (value == null) {\n            // Otherwise, check if it is set as an inline style\n            value = parseScrollBehaviorFromStyleAttribute(target);\n        }\n        if (value == null) {\n            // Take the computed style for the element and see if it contains a specific 'scroll-behavior' value\n            var computedStyle = getComputedStyle(target);\n            var computedStyleValue = computedStyle.getPropertyValue(\"scrollBehavior\");\n            if (computedStyleValue != null && computedStyleValue !== \"\") {\n                value = computedStyleValue;\n            }\n        }\n        // In all other cases, use the value from the CSSOM\n        return value;\n    }\n\n    \n\n    \n\n    var HALF = 0.5;\n    /**\n     * The easing function to use when applying the smooth scrolling\n     * @param {number} k\n     * @returns {number}\n     */\n    function ease(k) {\n        return HALF * (1 - Math.cos(Math.PI * k));\n    }\n\n    var NOOP = {\n        reset: function () { }\n    };\n    var map = typeof WeakMap === \"undefined\" ? undefined : new WeakMap();\n    function disableScrollSnap(scroller) {\n        // If scroll-behavior is natively supported, or if there is no native WeakMap support, there's no need for this fix\n        if (SUPPORTS_SCROLL_BEHAVIOR || map == null) {\n            return NOOP;\n        }\n        var scrollingElement = getScrollingElement();\n        var cachedScrollSnapValue;\n        var cachedScrollBehaviorStyleAttributeValue;\n        var secondaryScroller;\n        var secondaryScrollerCachedScrollSnapValue;\n        var secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n        var existingResult = map.get(scroller);\n        if (existingResult != null) {\n            cachedScrollSnapValue = existingResult.cachedScrollSnapValue;\n            cachedScrollBehaviorStyleAttributeValue = existingResult.cachedScrollBehaviorStyleAttributeValue;\n            secondaryScroller = existingResult.secondaryScroller;\n            secondaryScrollerCachedScrollSnapValue = existingResult.secondaryScrollerCachedScrollSnapValue;\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue = existingResult.secondaryScrollerCachedScrollBehaviorStyleAttributeValue;\n            existingResult.release();\n        }\n        else {\n            cachedScrollSnapValue = scroller.style.scrollSnapType === \"\" ? null : scroller.style.scrollSnapType;\n            cachedScrollBehaviorStyleAttributeValue = parseScrollBehaviorFromStyleAttribute(scroller);\n            secondaryScroller = scroller === scrollingElement && scrollingElement !== document.body ? document.body : undefined;\n            secondaryScrollerCachedScrollSnapValue =\n                secondaryScroller == null ? undefined : secondaryScroller.style.scrollSnapType === \"\" ? null : secondaryScroller.style.scrollSnapType;\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue =\n                secondaryScroller == null ? undefined : parseScrollBehaviorFromStyleAttribute(secondaryScroller);\n            var cachedComputedScrollSnapValue = getComputedStyle(scroller).getPropertyValue(\"scroll-snap-type\");\n            var secondaryScrollerCachedComputedScrollSnapValue = secondaryScroller == null ? undefined : getComputedStyle(secondaryScroller).getPropertyValue(\"scroll-snap-type\");\n            // If it just so happens that there actually isn't any scroll snapping going on, there's no point in performing any additional work here.\n            if (cachedComputedScrollSnapValue === \"none\" && secondaryScrollerCachedComputedScrollSnapValue === \"none\") {\n                return NOOP;\n            }\n        }\n        scroller.style.scrollSnapType = \"none\";\n        if (secondaryScroller !== undefined) {\n            secondaryScroller.style.scrollSnapType = \"none\";\n        }\n        if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n            appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n        }\n        if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n            appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n        }\n        var hasReleased = false;\n        var eventTarget = scroller === scrollingElement ? window : scroller;\n        function release() {\n            eventTarget.removeEventListener(\"scroll\", resetHandler);\n            if (map != null) {\n                map[\"delete\"](scroller);\n            }\n            hasReleased = true;\n        }\n        function resetHandler() {\n            scroller.style.scrollSnapType = cachedScrollSnapValue;\n            if (secondaryScroller != null && secondaryScrollerCachedScrollSnapValue !== undefined) {\n                secondaryScroller.style.scrollSnapType = secondaryScrollerCachedScrollSnapValue;\n            }\n            if (cachedScrollBehaviorStyleAttributeValue !== undefined) {\n                appendScrollBehaviorToStyleAttribute(scroller, cachedScrollBehaviorStyleAttributeValue);\n            }\n            if (secondaryScroller !== undefined && secondaryScrollerCachedScrollBehaviorStyleAttributeValue !== undefined) {\n                appendScrollBehaviorToStyleAttribute(secondaryScroller, secondaryScrollerCachedScrollBehaviorStyleAttributeValue);\n            }\n            release();\n        }\n        function reset() {\n            setTimeout(function () {\n                if (hasReleased)\n                    return;\n                eventTarget.addEventListener(\"scroll\", resetHandler);\n            });\n        }\n        map.set(scroller, {\n            release: release,\n            cachedScrollSnapValue: cachedScrollSnapValue,\n            cachedScrollBehaviorStyleAttributeValue: cachedScrollBehaviorStyleAttributeValue,\n            secondaryScroller: secondaryScroller,\n            secondaryScrollerCachedScrollSnapValue: secondaryScrollerCachedScrollSnapValue,\n            secondaryScrollerCachedScrollBehaviorStyleAttributeValue: secondaryScrollerCachedScrollBehaviorStyleAttributeValue\n        });\n        return {\n            reset: reset\n        };\n    }\n\n    /**\n     * The duration of a smooth scroll\n     * @type {number}\n     */\n    var SCROLL_TIME = 15000;\n    /**\n     * Performs a smooth repositioning of the scroll\n     * @param {ISmoothScrollOptions} options\n     */\n    function smoothScroll(options) {\n        var startTime = options.startTime, startX = options.startX, startY = options.startY, endX = options.endX, endY = options.endY, method = options.method, scroller = options.scroller;\n        var timeLapsed = 0;\n        var distanceX = endX - startX;\n        var distanceY = endY - startY;\n        var speed = Math.max(Math.abs((distanceX / 1000) * SCROLL_TIME), Math.abs((distanceY / 1000) * SCROLL_TIME));\n        // Temporarily disables any scroll snapping that may be active since it fights for control over the scroller with this polyfill\n        var scrollSnapFix = disableScrollSnap(scroller);\n        requestAnimationFrame(function animate(timestamp) {\n            timeLapsed += timestamp - startTime;\n            var percentage = Math.max(0, Math.min(1, speed === 0 ? 0 : timeLapsed / speed));\n            var positionX = Math.floor(startX + distanceX * ease(percentage));\n            var positionY = Math.floor(startY + distanceY * ease(percentage));\n            method(positionX, positionY);\n            if (positionX !== endX || positionY !== endY) {\n                requestAnimationFrame(animate);\n            }\n            else {\n                if (scrollSnapFix != null) {\n                    scrollSnapFix.reset();\n                    scrollSnapFix = undefined;\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns a High Resolution timestamp if possible, otherwise fallbacks to Date.now()\n     * @returns {number}\n     */\n    function now() {\n        if (\"performance\" in window)\n            return performance.now();\n        return Date.now();\n    }\n\n    \n\n    var ELEMENT_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scroll;\n\n    var WINDOW_ORIGINAL_SCROLL = UNSUPPORTED_ENVIRONMENT ? undefined : window.scroll;\n\n    var ELEMENT_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollBy;\n\n    var WINDOW_ORIGINAL_SCROLL_BY = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollBy;\n\n    var ELEMENT_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollTo;\n\n    var WINDOW_ORIGINAL_SCROLL_TO = UNSUPPORTED_ENVIRONMENT ? undefined : window.scrollTo;\n\n    /**\n     * A fallback if Element.prototype.scroll is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollFallback(x, y) {\n        this.__adjustingScrollPosition = true;\n        this.scrollLeft = x;\n        this.scrollTop = y;\n        delete this.__adjustingScrollPosition;\n    }\n    /**\n     * A fallback if Element.prototype.scrollTo is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollToFallback(x, y) {\n        return elementPrototypeScrollFallback.call(this, x, y);\n    }\n    /**\n     * A fallback if Element.prototype.scrollBy is not defined\n     * @param {number} x\n     * @param {number} y\n     */\n    function elementPrototypeScrollByFallback(x, y) {\n        this.__adjustingScrollPosition = true;\n        this.scrollLeft += x;\n        this.scrollTop += y;\n        delete this.__adjustingScrollPosition;\n    }\n    /**\n     * Gets the original non-patched prototype method for the given kind\n     * @param {ScrollMethodName} kind\n     * @param {Element|Window} element\n     * @return {Function}\n     */\n    function getOriginalScrollMethodForKind(kind, element) {\n        switch (kind) {\n            case \"scroll\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL != null) {\n                        return ELEMENT_ORIGINAL_SCROLL;\n                    }\n                    else {\n                        return elementPrototypeScrollFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL;\n                }\n            case \"scrollBy\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL_BY != null) {\n                        return ELEMENT_ORIGINAL_SCROLL_BY;\n                    }\n                    else {\n                        return elementPrototypeScrollByFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL_BY;\n                }\n            case \"scrollTo\":\n                if (element instanceof Element) {\n                    if (ELEMENT_ORIGINAL_SCROLL_TO != null) {\n                        return ELEMENT_ORIGINAL_SCROLL_TO;\n                    }\n                    else {\n                        return elementPrototypeScrollToFallback;\n                    }\n                }\n                else {\n                    return WINDOW_ORIGINAL_SCROLL_TO;\n                }\n        }\n    }\n\n    /**\n     * Gets the Smooth Scroll Options to use for the step function\n     * @param {Element|Window} element\n     * @param {number} x\n     * @param {number} y\n     * @param {ScrollMethodName} kind\n     * @returns {ISmoothScrollOptions}\n     */\n    function getSmoothScrollOptions(element, x, y, kind) {\n        var startTime = now();\n        if (!(element instanceof Element)) {\n            // Use window as the scroll container\n            var scrollX_1 = window.scrollX, pageXOffset_1 = window.pageXOffset, scrollY_1 = window.scrollY, pageYOffset_1 = window.pageYOffset;\n            var startX = scrollX_1 == null || scrollX_1 === 0 ? pageXOffset_1 : scrollX_1;\n            var startY = scrollY_1 == null || scrollY_1 === 0 ? pageYOffset_1 : scrollY_1;\n            return {\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n                endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n                method: getOriginalScrollMethodForKind(\"scrollTo\", window).bind(window),\n                scroller: getScrollingElement()\n            };\n        }\n        else {\n            var scrollLeft = element.scrollLeft, scrollTop = element.scrollTop;\n            var startX = scrollLeft;\n            var startY = scrollTop;\n            return {\n                startTime: startTime,\n                startX: startX,\n                startY: startY,\n                endX: Math.floor(kind === \"scrollBy\" ? startX + x : x),\n                endY: Math.floor(kind === \"scrollBy\" ? startY + y : y),\n                method: getOriginalScrollMethodForKind(\"scrollTo\", element).bind(element),\n                scroller: element\n            };\n        }\n    }\n\n    /**\n     * Ensures that the given value is numeric\n     * @param {number} value\n     * @return {number}\n     */\n    function ensureNumeric(value) {\n        if (value == null)\n            return 0;\n        else if (typeof value === \"number\") {\n            return value;\n        }\n        else if (typeof value === \"string\") {\n            return parseFloat(value);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns true if the given value is some ScrollToOptions\n     * @param {number | ScrollToOptions} value\n     * @return {value is ScrollToOptions}\n     */\n    function isScrollToOptions(value) {\n        return value != null && typeof value === \"object\";\n    }\n\n    /**\n     * Handles a scroll method\n     * @param {Element|Window} element\n     * @param {ScrollMethodName} kind\n     * @param {number | ScrollToOptions} optionsOrX\n     * @param {number} y\n     */\n    function handleScrollMethod(element, kind, optionsOrX, y) {\n        onScrollWithOptions(getScrollToOptionsWithValidation(optionsOrX, y), element, kind);\n    }\n    /**\n     * Invoked when a 'ScrollToOptions' dict is provided to 'scroll()' as the first argument\n     * @param {ScrollToOptions} options\n     * @param {Element|Window} element\n     * @param {ScrollMethodName} kind\n     */\n    function onScrollWithOptions(options, element, kind) {\n        var behavior = getScrollBehavior(element, options);\n        // If the behavior is 'auto' apply instantaneous scrolling\n        if (behavior == null || behavior === \"auto\") {\n            getOriginalScrollMethodForKind(kind, element).call(element, options.left, options.top);\n        }\n        else {\n            smoothScroll(getSmoothScrollOptions(element, options.left, options.top, kind));\n        }\n    }\n    /**\n     * Normalizes the given scroll coordinates\n     * @param {number?} x\n     * @param {number?} y\n     * @return {Required<Pick<ScrollToOptions, \"top\" | \"left\">>}\n     */\n    function normalizeScrollCoordinates(x, y) {\n        return {\n            left: ensureNumeric(x),\n            top: ensureNumeric(y)\n        };\n    }\n    /**\n     * Gets ScrollToOptions based on the given arguments. Will throw if validation fails\n     * @param {number | ScrollToOptions} optionsOrX\n     * @param {number} y\n     * @return {Required<ScrollToOptions>}\n     */\n    function getScrollToOptionsWithValidation(optionsOrX, y) {\n        // If only one argument is given, and it isn't an options object, throw a TypeError\n        if (y === undefined && !isScrollToOptions(optionsOrX)) {\n            throw new TypeError(\"Failed to execute 'scroll' on 'Element': parameter 1 ('options') is not an object.\");\n        }\n        // Scroll based on the primitive values given as arguments\n        if (!isScrollToOptions(optionsOrX)) {\n            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX, y)), { behavior: \"auto\" });\n        }\n        // Scroll based on the received options object\n        else {\n            return __assign(__assign({}, normalizeScrollCoordinates(optionsOrX.left, optionsOrX.top)), { behavior: optionsOrX.behavior == null ? \"auto\" : optionsOrX.behavior });\n        }\n    }\n\n    /**\n     * Patches the 'scroll' method on the Element prototype\n     */\n    function patchElementScroll() {\n        Element.prototype.scroll = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scroll\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollBy' method on the Element prototype\n     */\n    function patchElementScrollBy() {\n        Element.prototype.scrollBy = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollTo' method on the Element prototype\n     */\n    function patchElementScrollTo() {\n        Element.prototype.scrollTo = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scroll' method on the Window prototype\n     */\n    function patchWindowScroll() {\n        window.scroll = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scroll\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollBy' method on the Window prototype\n     */\n    function patchWindowScrollBy() {\n        window.scrollBy = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollBy\", optionsOrX, y);\n        };\n    }\n\n    /**\n     * Patches the 'scrollTo' method on the Window prototype\n     */\n    function patchWindowScrollTo() {\n        window.scrollTo = function (optionsOrX, y) {\n            handleScrollMethod(this, \"scrollTo\", optionsOrX, y);\n        };\n    }\n\n    // tslint:disable:no-any\n    /**\n     * Gets the parent of an element, taking into account DocumentFragments, ShadowRoots, as well as the root context (window)\n     * @param {EventTarget} currentElement\n     * @returns {EventTarget | null}\n     */\n    function getParent(currentElement) {\n        if (\"nodeType\" in currentElement && currentElement.nodeType === 1) {\n            return currentElement.parentNode;\n        }\n        if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n            return currentElement.host;\n        }\n        else if (currentElement === document) {\n            return window;\n        }\n        else if (currentElement instanceof Node)\n            return currentElement.parentNode;\n        return null;\n    }\n\n    /**\n     * Returns true if the given overflow property represents a scrollable overflow value\n     * @param {string | null} overflow\n     * @return {boolean}\n     */\n    function canOverflow(overflow) {\n        return overflow !== \"visible\" && overflow !== \"clip\";\n    }\n    /**\n     * Returns true if the given element is scrollable\n     * @param {Element} element\n     * @return {boolean}\n     */\n    function isScrollable(element) {\n        if (element.clientHeight < element.scrollHeight || element.clientWidth < element.scrollWidth) {\n            var style = getComputedStyle(element, null);\n            return canOverflow(style.overflowY) || canOverflow(style.overflowX);\n        }\n        return false;\n    }\n    /**\n     * Finds the nearest ancestor of an element that can scroll\n     * @param {Element} target\n     * @returns {Element|Window?}\n     */\n    function findNearestAncestorsWithScrollBehavior(target) {\n        var currentElement = target;\n        var scrollingElement = getScrollingElement();\n        while (currentElement != null) {\n            var behavior = getScrollBehavior(currentElement);\n            if (behavior != null && (currentElement === scrollingElement || isScrollable(currentElement))) {\n                return [currentElement, behavior];\n            }\n            var parent_1 = getParent(currentElement);\n            currentElement = parent_1;\n        }\n        // No such element could be found. Start over, but this time find the nearest ancestor that can simply scroll\n        currentElement = target;\n        while (currentElement != null) {\n            if (currentElement === scrollingElement || isScrollable(currentElement)) {\n                return [currentElement, \"auto\"];\n            }\n            var parent_2 = getParent(currentElement);\n            currentElement = parent_2;\n        }\n        // Default to the scrolling element\n        return [scrollingElement, \"auto\"];\n    }\n\n    // tslint:disable:no-any\n    /**\n     * Finds the nearest root from an element\n     * @param {Element} target\n     * @returns {Document|ShadowRoot}\n     */\n    function findNearestRoot(target) {\n        var currentElement = target;\n        while (currentElement != null) {\n            if (\"ShadowRoot\" in window && currentElement instanceof window.ShadowRoot) {\n                // Assume this is a ShadowRoot\n                return currentElement;\n            }\n            var parent_1 = getParent(currentElement);\n            if (parent_1 === currentElement) {\n                return document;\n            }\n            currentElement = parent_1;\n        }\n        return document;\n    }\n\n    /**\n     * Gets the origin of the given Location or HTMLAnchorElement if available in the runtime, and otherwise shims it. (it's a one-liner)\n     * @returns {string}\n     */\n    function getLocationOrigin(locationLike) {\n        if (locationLike === void 0) { locationLike = location; }\n        if (\"origin\" in locationLike && locationLike.origin != null) {\n            return locationLike.origin;\n        }\n        var port = locationLike.port != null && locationLike.port.length > 0 ? \":\" + locationLike.port : \"\";\n        if (locationLike.protocol === \"http:\" && port === \":80\") {\n            port = \"\";\n        }\n        else if (locationLike.protocol === \"https:\" && port === \":443\") {\n            port = \"\";\n        }\n        return locationLike.protocol + \"//\" + locationLike.hostname + port;\n    }\n\n    /**\n     * A Regular expression that matches id's of the form \"#[digit]\"\n     * @type {RegExp}\n     */\n    var ID_WITH_LEADING_DIGIT_REGEXP = /^#\\d/;\n    /**\n     * Catches anchor navigation to IDs within the same root and ensures that they can be smooth-scrolled\n     * if the scroll behavior is smooth in the first rooter within that context\n     */\n    function catchNavigation() {\n        // Listen for 'click' events globally\n        window.addEventListener(\"click\", function (e) {\n            // Only work with trusted events on HTMLAnchorElements\n            if (!e.isTrusted || !(e.target instanceof HTMLAnchorElement))\n                return;\n            var _a = e.target, pathname = _a.pathname, search = _a.search, hash = _a.hash;\n            var pointsToCurrentPage = getLocationOrigin(e.target) === getLocationOrigin(location) && pathname === location.pathname && search === location.search;\n            // Only work with HTMLAnchorElements that navigates to a specific ID on the current page\n            if (!pointsToCurrentPage || hash == null || hash.length < 1) {\n                return;\n            }\n            // Find the nearest root, whether it be a ShadowRoot or the document itself\n            var root = findNearestRoot(e.target);\n            // Attempt to match the selector from that root. querySelector' doesn't support IDs that start with a digit, so work around that limitation\n            var elementMatch = hash.match(ID_WITH_LEADING_DIGIT_REGEXP) != null ? root.getElementById(hash.slice(1)) : root.querySelector(hash);\n            // If no selector could be found, don't proceed\n            if (elementMatch == null)\n                return;\n            // Find the nearest ancestor that can be scrolled\n            var _b = __read(findNearestAncestorsWithScrollBehavior(elementMatch), 2), behavior = _b[1];\n            // If the behavior isn't smooth, don't proceed\n            if (behavior !== \"smooth\")\n                return;\n            // Otherwise, first prevent the default action.\n            e.preventDefault();\n            // Now, scroll to the element with that ID\n            elementMatch.scrollIntoView({\n                behavior: behavior\n            });\n        });\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_INTO_VIEW = UNSUPPORTED_ENVIRONMENT ? undefined : Element.prototype.scrollIntoView;\n\n    /**\n     * The majority of this file is based on https://github.com/stipsan/compute-scroll-into-view (MIT license),\n     * but has been rewritten to accept a scroller as an argument.\n     */\n    /**\n     * Find out which edge to align against when logical scroll position is \"nearest\"\n     * Interesting fact: \"nearest\" works similarly to \"if-needed\", if the element is fully visible it will not scroll it\n     *\n     * Legends:\n     * ┌────────┐ ┏ ━ ━ ━ ┓\n     * │ target │   frame\n     * └────────┘ ┗ ━ ━ ━ ┛\n     */\n    function alignNearest(scrollingEdgeStart, scrollingEdgeEnd, scrollingSize, scrollingBorderStart, scrollingBorderEnd, elementEdgeStart, elementEdgeEnd, elementSize) {\n        /**\n         * If element edge A and element edge B are both outside scrolling box edge A and scrolling box edge B\n         *\n         *          ┌──┐\n         *        ┏━│━━│━┓\n         *          │  │\n         *        ┃ │  │ ┃        do nothing\n         *          │  │\n         *        ┗━│━━│━┛\n         *          └──┘\n         *\n         *  If element edge C and element edge D are both outside scrolling box edge C and scrolling box edge D\n         *\n         *    ┏ ━ ━ ━ ━ ┓\n         *   ┌───────────┐\n         *   │┃         ┃│        do nothing\n         *   └───────────┘\n         *    ┗ ━ ━ ━ ━ ┛\n         */\n        if ((elementEdgeStart < scrollingEdgeStart && elementEdgeEnd > scrollingEdgeEnd) ||\n            (elementEdgeStart > scrollingEdgeStart && elementEdgeEnd < scrollingEdgeEnd)) {\n            return 0;\n        }\n        /**\n         * If element edge A is outside scrolling box edge A and element height is less than scrolling box height\n         *\n         *          ┌──┐\n         *        ┏━│━━│━┓         ┏━┌━━┐━┓\n         *          └──┘             │  │\n         *  from  ┃      ┃     to  ┃ └──┘ ┃\n         *\n         *        ┗━ ━━ ━┛         ┗━ ━━ ━┛\n         *\n         * If element edge B is outside scrolling box edge B and element height is greater than scrolling box height\n         *\n         *        ┏━ ━━ ━┓         ┏━┌━━┐━┓\n         *                           │  │\n         *  from  ┃ ┌──┐ ┃     to  ┃ │  │ ┃\n         *          │  │             │  │\n         *        ┗━│━━│━┛         ┗━│━━│━┛\n         *          │  │             └──┘\n         *          │  │\n         *          └──┘\n         *\n         * If element edge C is outside scrolling box edge C and element width is less than scrolling box width\n         *\n         *       from                 to\n         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *  ┌───┐                 ┌───┐\n         *  │ ┃ │       ┃         ┃   │     ┃\n         *  └───┘                 └───┘\n         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         * If element edge D is outside scrolling box edge D and element width is greater than scrolling box width\n         *\n         *       from                 to\n         *    ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *        ┌───────────┐   ┌───────────┐\n         *    ┃   │     ┃     │   ┃         ┃ │\n         *        └───────────┘   └───────────┘\n         *    ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         */\n        if ((elementEdgeStart <= scrollingEdgeStart && elementSize <= scrollingSize) ||\n            (elementEdgeEnd >= scrollingEdgeEnd && elementSize >= scrollingSize)) {\n            return elementEdgeStart - scrollingEdgeStart - scrollingBorderStart;\n        }\n        /**\n         * If element edge B is outside scrolling box edge B and element height is less than scrolling box height\n         *\n         *        ┏━ ━━ ━┓         ┏━ ━━ ━┓\n         *\n         *  from  ┃      ┃     to  ┃ ┌──┐ ┃\n         *          ┌──┐             │  │\n         *        ┗━│━━│━┛         ┗━└━━┘━┛\n         *          └──┘\n         *\n         * If element edge A is outside scrolling box edge A and element height is greater than scrolling box height\n         *\n         *          ┌──┐\n         *          │  │\n         *          │  │             ┌──┐\n         *        ┏━│━━│━┓         ┏━│━━│━┓\n         *          │  │             │  │\n         *  from  ┃ └──┘ ┃     to  ┃ │  │ ┃\n         *                           │  │\n         *        ┗━ ━━ ━┛         ┗━└━━┘━┛\n         *\n         * If element edge C is outside scrolling box edge C and element width is greater than scrolling box width\n         *\n         *           from                 to\n         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *  ┌───────────┐           ┌───────────┐\n         *  │     ┃     │   ┃       │ ┃         ┃\n         *  └───────────┘           └───────────┘\n         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         * If element edge D is outside scrolling box edge D and element width is less than scrolling box width\n         *\n         *           from                 to\n         *        ┏ ━ ━ ━ ━ ┓         ┏ ━ ━ ━ ━ ┓\n         *                ┌───┐             ┌───┐\n         *        ┃       │ ┃ │       ┃     │   ┃\n         *                └───┘             └───┘\n         *        ┗ ━ ━ ━ ━ ┛         ┗ ━ ━ ━ ━ ┛\n         *\n         */\n        if ((elementEdgeEnd > scrollingEdgeEnd && elementSize < scrollingSize) || (elementEdgeStart < scrollingEdgeStart && elementSize > scrollingSize)) {\n            return elementEdgeEnd - scrollingEdgeEnd + scrollingBorderEnd;\n        }\n        return 0;\n    }\n    function computeScrollIntoView(target, scroller, options) {\n        var block = options.block, inline = options.inline;\n        // Used to handle the top most element that can be scrolled\n        var scrollingElement = getScrollingElement();\n        // Support pinch-zooming properly, making sure elements scroll into the visual viewport\n        // Browsers that don't support visualViewport will report the layout viewport dimensions on document.documentElement.clientWidth/Height\n        // and viewport dimensions on window.innerWidth/Height\n        // https://www.quirksmode.org/mobile/viewports2.html\n        // https://bokand.github.io/viewport/index.html\n        var viewportWidth = window.visualViewport != null ? visualViewport.width : innerWidth;\n        var viewportHeight = window.visualViewport != null ? visualViewport.height : innerHeight;\n        var viewportX = window.scrollX != null ? window.scrollX : window.pageXOffset;\n        var viewportY = window.scrollY != null ? window.scrollY : window.pageYOffset;\n        var _a = target.getBoundingClientRect(), targetHeight = _a.height, targetWidth = _a.width, targetTop = _a.top, targetRight = _a.right, targetBottom = _a.bottom, targetLeft = _a.left;\n        // These values mutate as we loop through and generate scroll coordinates\n        var targetBlock = block === \"start\" || block === \"nearest\" ? targetTop : block === \"end\" ? targetBottom : targetTop + targetHeight / 2; // block === 'center\n        var targetInline = inline === \"center\" ? targetLeft + targetWidth / 2 : inline === \"end\" ? targetRight : targetLeft; // inline === 'start || inline === 'nearest\n        var _b = scroller.getBoundingClientRect(), height = _b.height, width = _b.width, top = _b.top, right = _b.right, bottom = _b.bottom, left = _b.left;\n        var frameStyle = getComputedStyle(scroller);\n        var borderLeft = parseInt(frameStyle.borderLeftWidth, 10);\n        var borderTop = parseInt(frameStyle.borderTopWidth, 10);\n        var borderRight = parseInt(frameStyle.borderRightWidth, 10);\n        var borderBottom = parseInt(frameStyle.borderBottomWidth, 10);\n        var blockScroll = 0;\n        var inlineScroll = 0;\n        // The property existance checks for offset[Width|Height] is because only HTMLElement objects have them, but any Element might pass by here\n        // @TODO find out if the \"as HTMLElement\" overrides can be dropped\n        var scrollbarWidth = \"offsetWidth\" in scroller ? scroller.offsetWidth - scroller.clientWidth - borderLeft - borderRight : 0;\n        var scrollbarHeight = \"offsetHeight\" in scroller ? scroller.offsetHeight - scroller.clientHeight - borderTop - borderBottom : 0;\n        if (scrollingElement === scroller) {\n            // Handle viewport logic (document.documentElement or document.body)\n            if (block === \"start\") {\n                blockScroll = targetBlock;\n            }\n            else if (block === \"end\") {\n                blockScroll = targetBlock - viewportHeight;\n            }\n            else if (block === \"nearest\") {\n                blockScroll = alignNearest(viewportY, viewportY + viewportHeight, viewportHeight, borderTop, borderBottom, viewportY + targetBlock, viewportY + targetBlock + targetHeight, targetHeight);\n            }\n            else {\n                // block === 'center' is the default\n                blockScroll = targetBlock - viewportHeight / 2;\n            }\n            if (inline === \"start\") {\n                inlineScroll = targetInline;\n            }\n            else if (inline === \"center\") {\n                inlineScroll = targetInline - viewportWidth / 2;\n            }\n            else if (inline === \"end\") {\n                inlineScroll = targetInline - viewportWidth;\n            }\n            else {\n                // inline === 'nearest' is the default\n                inlineScroll = alignNearest(viewportX, viewportX + viewportWidth, viewportWidth, borderLeft, borderRight, viewportX + targetInline, viewportX + targetInline + targetWidth, targetWidth);\n            }\n            // Apply scroll position offsets and ensure they are within bounds\n            // @TODO add more test cases to cover this 100%\n            blockScroll = Math.max(0, blockScroll + viewportY);\n            inlineScroll = Math.max(0, inlineScroll + viewportX);\n        }\n        else {\n            // Handle each scrolling frame that might exist between the target and the viewport\n            if (block === \"start\") {\n                blockScroll = targetBlock - top - borderTop;\n            }\n            else if (block === \"end\") {\n                blockScroll = targetBlock - bottom + borderBottom + scrollbarHeight;\n            }\n            else if (block === \"nearest\") {\n                blockScroll = alignNearest(top, bottom, height, borderTop, borderBottom + scrollbarHeight, targetBlock, targetBlock + targetHeight, targetHeight);\n            }\n            else {\n                // block === 'center' is the default\n                blockScroll = targetBlock - (top + height / 2) + scrollbarHeight / 2;\n            }\n            if (inline === \"start\") {\n                inlineScroll = targetInline - left - borderLeft;\n            }\n            else if (inline === \"center\") {\n                inlineScroll = targetInline - (left + width / 2) + scrollbarWidth / 2;\n            }\n            else if (inline === \"end\") {\n                inlineScroll = targetInline - right + borderRight + scrollbarWidth;\n            }\n            else {\n                // inline === 'nearest' is the default\n                inlineScroll = alignNearest(left, right, width, borderLeft, borderRight + scrollbarWidth, targetInline, targetInline + targetWidth, targetWidth);\n            }\n            var scrollLeft = scroller.scrollLeft, scrollTop = scroller.scrollTop;\n            // Ensure scroll coordinates are not out of bounds while applying scroll offsets\n            blockScroll = Math.max(0, Math.min(scrollTop + blockScroll, scroller.scrollHeight - height + scrollbarHeight));\n            inlineScroll = Math.max(0, Math.min(scrollLeft + inlineScroll, scroller.scrollWidth - width + scrollbarWidth));\n        }\n        return {\n            top: blockScroll,\n            left: inlineScroll\n        };\n    }\n\n    /**\n     * Patches the 'scrollIntoView' method on the Element prototype\n     */\n    function patchElementScrollIntoView() {\n        Element.prototype.scrollIntoView = function (arg) {\n            var normalizedOptions = arg == null || arg === true\n                ? {\n                    block: \"start\",\n                    inline: \"nearest\"\n                }\n                : arg === false\n                    ? {\n                        block: \"end\",\n                        inline: \"nearest\"\n                    }\n                    : arg;\n            // Find the nearest ancestor that can be scrolled\n            var _a = __read(findNearestAncestorsWithScrollBehavior(this), 2), ancestorWithScroll = _a[0], ancestorWithScrollBehavior = _a[1];\n            var behavior = normalizedOptions.behavior != null ? normalizedOptions.behavior : ancestorWithScrollBehavior;\n            // If the behavior isn't smooth, simply invoke the original implementation and do no more\n            if (behavior !== \"smooth\") {\n                // Assert that 'scrollIntoView' is actually defined\n                if (ELEMENT_ORIGINAL_SCROLL_INTO_VIEW != null) {\n                    ELEMENT_ORIGINAL_SCROLL_INTO_VIEW.call(this, normalizedOptions);\n                }\n                // Otherwise, invoke 'scrollTo' instead and provide the scroll coordinates\n                else {\n                    var _b = computeScrollIntoView(this, ancestorWithScroll, normalizedOptions), top_1 = _b.top, left = _b.left;\n                    getOriginalScrollMethodForKind(\"scrollTo\", this).call(this, left, top_1);\n                }\n                return;\n            }\n            ancestorWithScroll.scrollTo(__assign({ behavior: behavior }, computeScrollIntoView(this, ancestorWithScroll, normalizedOptions)));\n        };\n        // On IE11, HTMLElement has its own declaration of scrollIntoView and does not inherit this from the prototype chain, so we'll need to patch that one too.\n        if (HTMLElement.prototype.scrollIntoView != null && HTMLElement.prototype.scrollIntoView !== Element.prototype.scrollIntoView) {\n            HTMLElement.prototype.scrollIntoView = Element.prototype.scrollIntoView;\n        }\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n        ? undefined\n        : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollTop\").set;\n\n    /**\n     * Patches the 'scrollTop' property descriptor on the Element prototype\n     */\n    function patchElementScrollTop() {\n        Object.defineProperty(Element.prototype, \"scrollTop\", {\n            set: function (scrollTop) {\n                if (this.__adjustingScrollPosition) {\n                    return ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR.call(this, scrollTop);\n                }\n                handleScrollMethod(this, \"scrollTo\", this.scrollLeft, scrollTop);\n                return scrollTop;\n            }\n        });\n    }\n\n    var ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR = UNSUPPORTED_ENVIRONMENT\n        ? undefined\n        : Object.getOwnPropertyDescriptor(Element.prototype, \"scrollLeft\").set;\n\n    /**\n     * Patches the 'scrollLeft' property descriptor on the Element prototype\n     */\n    function patchElementScrollLeft() {\n        Object.defineProperty(Element.prototype, \"scrollLeft\", {\n            set: function (scrollLeft) {\n                if (this.__adjustingScrollPosition) {\n                    return ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR.call(this, scrollLeft);\n                }\n                handleScrollMethod(this, \"scrollTo\", scrollLeft, this.scrollTop);\n                return scrollLeft;\n            }\n        });\n    }\n\n    /**\n     * Applies the polyfill\n     */\n    function patch() {\n        // Element.prototype methods\n        patchElementScroll();\n        patchElementScrollBy();\n        patchElementScrollTo();\n        patchElementScrollIntoView();\n        // Element.prototype descriptors\n        patchElementScrollLeft();\n        patchElementScrollTop();\n        // window methods\n        patchWindowScroll();\n        patchWindowScrollBy();\n        patchWindowScrollTo();\n        // Navigation\n        catchNavigation();\n    }\n\n    /**\n     * Is true if the browser natively supports the Element.prototype.[scroll|scrollTo|scrollBy|scrollIntoView] methods\n     * @type {boolean}\n     */\n    var SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS = UNSUPPORTED_ENVIRONMENT\n        ? false\n        : \"scroll\" in Element.prototype && \"scrollTo\" in Element.prototype && \"scrollBy\" in Element.prototype && \"scrollIntoView\" in Element.prototype;\n\n    if (!UNSUPPORTED_ENVIRONMENT && (!SUPPORTS_SCROLL_BEHAVIOR || !SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS)) {\n        patch();\n    }\n\n}());\n//# sourceMappingURL=index.js.map\n"],"names":["UNSUPPORTED_ENVIRONMENT","window","SUPPORTS_SCROLL_BEHAVIOR","document","documentElement","style","__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","this","__read","o","m","Symbol","iterator","r","e","ar","next","done","push","value","error","getScrollingElement","scrollingElement","STYLE_ATTRIBUTE_PROPERTY_REGEXP","RegExp","STYLE_ATTRIBUTE_PROPERTY_NAME","appendScrollBehaviorToStyleAttribute","element","behavior","addition","attributeValue","getAttribute","existingValueForProperty","parseScrollBehaviorFromStyleAttribute","replacementProperty","replace","setAttribute","endsWith","styleAttributeValue","includes","match","getScrollBehavior","inputTarget","options","target","scrollBehaviorPropertyValue","computedStyleValue","getComputedStyle","getPropertyValue","ease","k","Math","cos","PI","NOOP","reset","map","WeakMap","undefined","smoothScroll","startTime","startX","startY","endX","endY","method","scroller","timeLapsed","distanceX","distanceY","speed","max","abs","scrollSnapFix","cachedScrollSnapValue","cachedScrollBehaviorStyleAttributeValue","secondaryScroller","secondaryScrollerCachedScrollSnapValue","secondaryScrollerCachedScrollBehaviorStyleAttributeValue","existingResult","get","release","scrollSnapType","body","cachedComputedScrollSnapValue","secondaryScrollerCachedComputedScrollSnapValue","hasReleased","eventTarget","removeEventListener","resetHandler","set","setTimeout","addEventListener","disableScrollSnap","requestAnimationFrame","animate","timestamp","percentage","min","positionX","floor","positionY","ELEMENT_ORIGINAL_SCROLL","Element","scroll","WINDOW_ORIGINAL_SCROLL","ELEMENT_ORIGINAL_SCROLL_BY","scrollBy","WINDOW_ORIGINAL_SCROLL_BY","ELEMENT_ORIGINAL_SCROLL_TO","scrollTo","WINDOW_ORIGINAL_SCROLL_TO","elementPrototypeScrollFallback","x","y","__adjustingScrollPosition","scrollLeft","scrollTop","elementPrototypeScrollToFallback","elementPrototypeScrollByFallback","getOriginalScrollMethodForKind","kind","getSmoothScrollOptions","performance","now","Date","bind","scrollX_1","scrollX","pageXOffset_1","pageXOffset","scrollY_1","scrollY","pageYOffset_1","pageYOffset","ensureNumeric","parseFloat","isScrollToOptions","handleScrollMethod","optionsOrX","left","top","onScrollWithOptions","TypeError","normalizeScrollCoordinates","getScrollToOptionsWithValidation","getParent","currentElement","nodeType","parentNode","ShadowRoot","host","Node","canOverflow","overflow","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","overflowY","overflowX","findNearestAncestorsWithScrollBehavior","getLocationOrigin","locationLike","location","origin","port","protocol","hostname","ID_WITH_LEADING_DIGIT_REGEXP","catchNavigation","isTrusted","HTMLAnchorElement","_a","pathname","search","hash","root","parent_1","findNearestRoot","elementMatch","getElementById","slice","querySelector","preventDefault","scrollIntoView","ELEMENT_ORIGINAL_SCROLL_INTO_VIEW","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","computeScrollIntoView","block","inline","viewportWidth","visualViewport","width","innerWidth","viewportHeight","height","innerHeight","viewportX","viewportY","getBoundingClientRect","targetHeight","targetWidth","targetTop","targetRight","right","targetBottom","bottom","targetLeft","targetBlock","targetInline","_b","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","ELEMENT_ORIGINAL_SCROLL_TOP_SET_DESCRIPTOR","getOwnPropertyDescriptor","ELEMENT_ORIGINAL_SCROLL_LEFT_SET_DESCRIPTOR","SUPPORTS_ELEMENT_PROTOTYPE_SCROLL_METHODS","arg","normalizedOptions","ancestorWithScroll","ancestorWithScrollBehavior","top_1","HTMLElement","defineProperty"],"mappings":"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"}